Reading the machine code
========================

There is a lot of inline machine code throughout :<cf>, so it's good to know the basics of reading it.

First of all, when comma-ing bytes, they are inscribed in the dictionary in reverse order. This is probably because the stack is little-endian, and I suspect it also makes :g<1,>, :g<2,>, and :g<3,> easier to implement. This means that an instruction like c28b0689 should be read backwards, like 89 06 8b c2.

Another thing to note is that all hex literals are 4 bytes. This means that 74 is really 00000074, and :g<74 2,> will comma in 74 00.

x86 machine code is generally in the form opcode modr/m. The opcode byte specifies which operation to perform, while the modr/m byte specifies its arguments.

The modr/m format, in bits, is:

 mode mode r r r r/m r/m r/m

where the first two bits specify the mode, the next three specify a [register](mem.html), and the final three specify another register.

Depending on the mode, the second register (r/m) will either be used directly, or its contents will be used as a pointer.

Modes are:
 00 - treat r/m as a pointer
 01 - treat r/m as a pointer, and an 8-bit offset value will follow
 10 - treat r/m as a pointer, and a 16-bit offset value will follow
 11 - treat them both as registers

For example, consider 8b16. If we [look up the opcode 8b](http://ref.x86asm.net/coder32.html#x8B), we find that it's a mov that takes r as the first argument and r/m as the second argument. 16 = 00010110 = 00 010 110. So, the mode is 00 (treat r/m as a pointer), r is edl, and r/m is esi. That means that these bytes translate to mov edl, [esi], or edl = *esi;

Further information can be found on the [osdev wiki](https://wiki.osdev.org/X86-64_Instruction_Encoding#ModR/M).
