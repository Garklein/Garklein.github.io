<!DOCTYPE html>
<html>
<head>
  <title>Garklein's stuff</title>
  <style>
body           { display:flex; flex-direction:column; align-items:center;
                 font-size:1rem; margin:min(10vw,100px) auto; }
pre            { max-width:min(80ch,80vw); margin:auto; white-space:pre-wrap; }
.code          { max-width:80vw; word-break:break-all; }
  </style>
</head>
<body><div>
<pre class='code'>
i:"-"\'0:"i/23.in"
a:=!/+(n:?,/i)?/:i,|'i                      / adjacency list, computer names
s:{(1=+/1&/''~^x?/:\:)#x}@?:                / remove elements that are subsets of others
c:n@(,!0){s@x,y,'(|/'y=a@)#'x}/!#n          / cliques
+/*'|/'"t"=(3=#:')#?{?x@&lt;x}',/{x@+!3##x}'c  / part 1: cliques of size 3 with a "t" computer
`0:","/l@&lt;l:c@*&gt;#'c                         / part 2: largest clique
</pre><pre>

Graph theory, my favourite...

Part 1 is a bit messy. I have a list of all cliques, but then I need to find all cliques of size 3. I couldn't think of a better way of doing this than generating all size 3 subsets of each clique, then sorting and deduping.

The clique finding can be made about 10x faster by using something like
c:n@(,!0){((&/'|/''y=a@)_x),y,'s(|/'y=a@)#'x}/!#n
but it's a lot nastier and just manually expanding out what's happening.
</pre>
<br>
<pre style='width:100%;text-align:center'><br><a href='../index.html'>~</a>/<a href='aoc24k.html'>aoc24k</a>/<a href='23.html'>23.html</a></pre>
</div></body>
</html>
